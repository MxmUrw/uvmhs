<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">UVMHS.Core.Matrix</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-2"></span><span>
</span><span id="line-3"></span><span class="hs-comment">-- import UVMHS.Core.Init</span><span>
</span><span id="line-4"></span><span class="hs-comment">-- import UVMHS.Core.Classes</span><span>
</span><span id="line-5"></span><span class="hs-comment">-- import UVMHS.Core.Data</span><span>
</span><span id="line-6"></span><span class="hs-comment">-- import UVMHS.Core.Pointed</span><span>
</span><span id="line-7"></span><span class="hs-comment">-- import UVMHS.Core.IO</span><span>
</span><span id="line-8"></span><span class="hs-comment">-- </span><span>
</span><span id="line-9"></span><span class="hs-comment">-- import qualified Data.Array.Repa as Repa</span><span>
</span><span id="line-10"></span><span class="hs-comment">-- import qualified Data.Array.Repa.Repr.Vector as Repa</span><span>
</span><span id="line-11"></span><span class="hs-comment">-- import qualified Data.Array.Repa.Repr.Unboxed as Repa</span><span>
</span><span id="line-12"></span><span class="hs-comment">-- import qualified Data.Array.Repa.Eval as Repa</span><span>
</span><span id="line-13"></span><span class="hs-comment">-- import qualified Prelude as HS</span><span>
</span><span id="line-14"></span><span class="hs-comment">-- import qualified Data.Proxy as HS</span><span>
</span><span id="line-15"></span><span class="hs-comment">-- import qualified Data.Functor.Identity as HS</span><span>
</span><span id="line-16"></span><span class="hs-comment">-- import qualified Data.Type.Equality as HS</span><span>
</span><span id="line-17"></span><span class="hs-comment">-- </span><span>
</span><span id="line-18"></span><span class="hs-comment">-- import qualified GHC.TypeLits as HS</span><span>
</span><span id="line-19"></span><span class="hs-comment">-- </span><span>
</span><span id="line-20"></span><span class="hs-comment">-- -- type lits --</span><span>
</span><span id="line-21"></span><span class="hs-comment">-- </span><span>
</span><span id="line-22"></span><span class="hs-comment">-- type T&#8469; = HS.Nat</span><span>
</span><span id="line-23"></span><span class="hs-comment">-- type T&#120138; = HS.Symbol</span><span>
</span><span id="line-24"></span><span class="hs-comment">-- </span><span>
</span><span id="line-25"></span><span class="hs-comment">-- type (m &#8759; T&#8469;) +  (n &#8759; T&#8469;) = m HS.+ n</span><span>
</span><span id="line-26"></span><span class="hs-comment">-- type (m &#8759; T&#8469;) &#215;  (n &#8759; T&#8469;) = m HS.* n</span><span>
</span><span id="line-27"></span><span class="hs-comment">-- type (m &#8759; T&#8469;) ^  (n &#8759; T&#8469;) = m HS.^ n</span><span>
</span><span id="line-28"></span><span class="hs-comment">-- type (m &#8759; T&#8469;) -  (n &#8759; T&#8469;) = m HS.- n</span><span>
</span><span id="line-29"></span><span class="hs-comment">-- type (m &#8759; T&#8469;) /  (n &#8759; T&#8469;) = m `HS.Div` n</span><span>
</span><span id="line-30"></span><span class="hs-comment">-- type (m &#8759; T&#8469;) %  (n &#8759; T&#8469;) = m `HS.Mod` n</span><span>
</span><span id="line-31"></span><span class="hs-comment">-- type Log2 (n &#8759; T&#8469;) = HS.Log2 n</span><span>
</span><span id="line-32"></span><span class="hs-comment">-- </span><span>
</span><span id="line-33"></span><span class="hs-comment">-- type (m &#8759; T&#8469;) &#8922;? (n &#8759; T&#8469;) = HS.CmpNat m n</span><span>
</span><span id="line-34"></span><span class="hs-comment">-- </span><span>
</span><span id="line-35"></span><span class="hs-comment">-- type (m &#8759; T&#8469;) &lt;  (n &#8759; T&#8469;) = (m &#8922;? n) ~ 'LT</span><span>
</span><span id="line-36"></span><span class="hs-comment">-- type (m &#8759; T&#8469;) &#8801;  (n &#8759; T&#8469;) = (m &#8922;? n) ~ 'EQ</span><span>
</span><span id="line-37"></span><span class="hs-comment">-- type (m &#8759; T&#8469;) &gt;  (n &#8759; T&#8469;) = (m &#8922;? n) ~ 'GT</span><span>
</span><span id="line-38"></span><span class="hs-comment">-- </span><span>
</span><span id="line-39"></span><span class="hs-comment">-- data (m &#8759; T&#8469;) :&lt;: (n &#8759; T&#8469;) = TRUSTME_LT</span><span>
</span><span id="line-40"></span><span class="hs-comment">-- </span><span>
</span><span id="line-41"></span><span class="hs-comment">-- newtype S&#8469; (n &#8759; T&#8469;) = TRUSTME_S&#8469; { unS&#8469; &#8759; &#8469; }</span><span>
</span><span id="line-42"></span><span class="hs-comment">-- newtype S&#8469;32 (n &#8759; T&#8469;) = TRUSTME_S&#8469;32 { unS&#8469;32 &#8759; &#8469;32 }</span><span>
</span><span id="line-43"></span><span class="hs-comment">-- newtype S&#120138; (s &#8759; T&#120138;) = TRUSTME_S&#120138; { unS&#120138; &#8759; &#120138; }</span><span>
</span><span id="line-44"></span><span class="hs-comment">-- </span><span>
</span><span id="line-45"></span><span class="hs-comment">-- class (HS.KnownNat n) &#8658; R&#8469; (n &#8759; T&#8469;) where reify&#8469; &#8759; P n &#8594; &#8469;</span><span>
</span><span id="line-46"></span><span class="hs-comment">-- class (HS.KnownNat n) &#8658; R&#8469;32 (n &#8759; T&#8469;) where reify&#8469;32 &#8759; P n &#8594; &#8469;32</span><span>
</span><span id="line-47"></span><span class="hs-comment">-- class (HS.KnownSymbol s) &#8658; R&#120138; (s &#8759; T&#120138;) where reify&#120138; &#8759; P s &#8594; &#120138;</span><span>
</span><span id="line-48"></span><span class="hs-comment">-- </span><span>
</span><span id="line-49"></span><span class="hs-comment">-- instance (HS.KnownNat n) &#8658; R&#8469; (n &#8759; T&#8469;) where reify&#8469; P = nat&#937; $ HS.natVal @ n P</span><span>
</span><span id="line-50"></span><span class="hs-comment">-- instance (HS.KnownNat n) &#8658; R&#8469;32 (n &#8759; T&#8469;) where reify&#8469;32 P = nat&#937;32 $ HS.natVal @ n P</span><span>
</span><span id="line-51"></span><span class="hs-comment">-- instance (HS.KnownSymbol s) &#8658; R&#120138; (s &#8759; T&#120138;) where reify&#120138; P = string $ HS.symbolVal @ s P</span><span>
</span><span id="line-52"></span><span class="hs-comment">-- </span><span>
</span><span id="line-53"></span><span class="hs-comment">-- compareT&#8469; &#8759; &#8704; (a &#8759; T&#8469;) (b &#8759; T&#8469;). (R&#8469; a,R&#8469; b) &#8658; &#119874; (a &#8799; b)</span><span>
</span><span id="line-54"></span><span class="hs-comment">-- compareT&#8469; = case HS.sameNat (HS.Proxy @ a) (HS.Proxy @ b) of</span><span>
</span><span id="line-55"></span><span class="hs-comment">--   HS.Nothing &#8594; None</span><span>
</span><span id="line-56"></span><span class="hs-comment">--   HS.Just HS.Refl &#8594; Some Refl</span><span>
</span><span id="line-57"></span><span class="hs-comment">-- </span><span>
</span><span id="line-58"></span><span class="hs-comment">-- s&#120159; &#8759; &#8704; n. (R&#8469; n) &#8658; S&#8469; n</span><span>
</span><span id="line-59"></span><span class="hs-comment">-- s&#120159; = TRUSTME_S&#8469; $ reify&#8469; @ n P</span><span>
</span><span id="line-60"></span><span class="hs-comment">-- </span><span>
</span><span id="line-61"></span><span class="hs-comment">-- d&#120159; &#8759; &#8469; &#8594; (&#8704; n. (R&#8469; n) &#8658; S&#8469; n &#8594; a) &#8594; a</span><span>
</span><span id="line-62"></span><span class="hs-comment">-- d&#120159; n f = case HS.someNatVal $ int n of</span><span>
</span><span id="line-63"></span><span class="hs-comment">--   HS.Nothing &#8594; error &quot;impossible&quot;</span><span>
</span><span id="line-64"></span><span class="hs-comment">--   HS.Just (HS.SomeNat (HS.Proxy &#8759; HS.Proxy n)) &#8594; f $ TRUSTME_S&#8469; @ n n</span><span>
</span><span id="line-65"></span><span class="hs-comment">-- </span><span>
</span><span id="line-66"></span><span class="hs-comment">-- s&#120159;32 &#8759; &#8704; n. (R&#8469;32 n) &#8658; S&#8469;32 n</span><span>
</span><span id="line-67"></span><span class="hs-comment">-- s&#120159;32 = TRUSTME_S&#8469;32 $ reify&#8469;32 @ n P</span><span>
</span><span id="line-68"></span><span class="hs-comment">-- </span><span>
</span><span id="line-69"></span><span class="hs-comment">-- d&#120159;32 &#8759; &#8469;32 &#8594; (&#8704; n. (R&#8469;32 n) &#8658; S&#8469;32 n &#8594; a) &#8594; a</span><span>
</span><span id="line-70"></span><span class="hs-comment">-- d&#120159;32 n f = case HS.someNatVal $ int n of</span><span>
</span><span id="line-71"></span><span class="hs-comment">--   HS.Nothing &#8594; error &quot;impossible&quot;</span><span>
</span><span id="line-72"></span><span class="hs-comment">--   HS.Just (HS.SomeNat (HS.Proxy &#8759; HS.Proxy n)) &#8594; f $ TRUSTME_S&#8469;32 @ n n</span><span>
</span><span id="line-73"></span><span class="hs-comment">-- </span><span>
</span><span id="line-74"></span><span class="hs-comment">-- s&#120164; &#8759; &#8704; s. (HS.KnownSymbol s) &#8658; S&#120138; s</span><span>
</span><span id="line-75"></span><span class="hs-comment">-- s&#120164; = TRUSTME_S&#120138; $ reify&#120138; @ s P</span><span>
</span><span id="line-76"></span><span class="hs-comment">-- </span><span>
</span><span id="line-77"></span><span class="hs-comment">-- d&#120164; &#8759; &#120138; &#8594; (&#8704; s. (R&#120138; s) &#8658; S&#120138; s &#8594; a) &#8594; a</span><span>
</span><span id="line-78"></span><span class="hs-comment">-- d&#120164; s f = case HS.someSymbolVal $ chars s of</span><span>
</span><span id="line-79"></span><span class="hs-comment">--   HS.SomeSymbol (HS.Proxy &#8759; HS.Proxy s) &#8594; f $ TRUSTME_S&#120138; @ s s</span><span>
</span><span id="line-80"></span><span class="hs-comment">-- </span><span>
</span><span id="line-81"></span><span class="hs-comment">-- infixr 8 :&amp;&amp;</span><span>
</span><span id="line-82"></span><span class="hs-comment">-- </span><span>
</span><span id="line-83"></span><span class="hs-comment">-- data S&#119871; (a &#8759; sa &#8594; &#9733;) &#8759; [sa] &#8594; &#9733; where</span><span>
</span><span id="line-84"></span><span class="hs-comment">--   SNil &#8759; S&#119871; a '[]</span><span>
</span><span id="line-85"></span><span class="hs-comment">--   (:&amp;&amp;) &#8759; a x &#8594; S&#119871; a xs &#8594; S&#119871; a (x ': xs)</span><span>
</span><span id="line-86"></span><span class="hs-comment">-- </span><span>
</span><span id="line-87"></span><span class="hs-comment">-- mapS&#119871; &#8759; &#8704; (a &#8759; sa &#8594; &#9733;) (b &#8759; sa &#8594; &#9733;) (xs &#8759; [sa]). (&#8704; (x &#8759; sa). a x &#8594; b x) &#8594; S&#119871; a xs &#8594; S&#119871; b xs</span><span>
</span><span id="line-88"></span><span class="hs-comment">-- mapS&#119871; _ SNil = SNil</span><span>
</span><span id="line-89"></span><span class="hs-comment">-- mapS&#119871; f (x :&amp;&amp; xs) = f x :&amp;&amp; mapS&#119871; f xs</span><span>
</span><span id="line-90"></span><span class="hs-comment">-- </span><span>
</span><span id="line-91"></span><span class="hs-comment">-- newtype Const (a &#8759; &#9733;) (b &#8759; k) = Const { unConst &#8759; a }</span><span>
</span><span id="line-92"></span><span class="hs-comment">-- </span><span>
</span><span id="line-93"></span><span class="hs-comment">-- type family (xs &#8759; [a]) &#10746; (ys &#8759; [a]) &#8759; [a] where</span><span>
</span><span id="line-94"></span><span class="hs-comment">--   '[] &#10746; ys = ys</span><span>
</span><span id="line-95"></span><span class="hs-comment">--   (x ': xs) &#10746; ys = x ': (xs &#10746; ys)</span><span>
</span><span id="line-96"></span><span class="hs-comment">-- </span><span>
</span><span id="line-97"></span><span class="hs-comment">-- -- indices --</span><span>
</span><span id="line-98"></span><span class="hs-comment">-- </span><span>
</span><span id="line-99"></span><span class="hs-comment">-- data &#120128;32 (n &#8759; T&#8469;) where</span><span>
</span><span id="line-100"></span><span class="hs-comment">--   &#120128;32 &#8759; S&#8469;32 m &#8594; m :&lt;: n &#8594; &#120128;32 n</span><span>
</span><span id="line-101"></span><span class="hs-comment">-- </span><span>
</span><span id="line-102"></span><span class="hs-comment">-- un&#120128;32 &#8759; &#120128;32 n &#8594; &#8469;32</span><span>
</span><span id="line-103"></span><span class="hs-comment">-- un&#120128;32 (&#120128;32 n _) = unS&#8469;32 n</span><span>
</span><span id="line-104"></span><span class="hs-comment">-- </span><span>
</span><span id="line-105"></span><span class="hs-comment">-- s&#120154; &#8759; &#8704; m n. (R&#8469;32 m,m &lt; n) &#8658; P m &#8594; &#120128;32 n</span><span>
</span><span id="line-106"></span><span class="hs-comment">-- s&#120154; P = &#120128;32 (s&#120159;32 @ m) TRUSTME_LT</span><span>
</span><span id="line-107"></span><span class="hs-comment">-- </span><span>
</span><span id="line-108"></span><span class="hs-comment">-- d&#120154; &#8759; S&#8469;32 m &#8594; &#8469;32 &#8594; &#119874; (&#120128;32 m)</span><span>
</span><span id="line-109"></span><span class="hs-comment">-- d&#120154; m n = case n &#8922; unS&#8469;32 m of</span><span>
</span><span id="line-110"></span><span class="hs-comment">--   LT &#8594; d&#120159;32 n $ \ n' &#8594; Some $ &#120128;32 n' TRUSTME_LT</span><span>
</span><span id="line-111"></span><span class="hs-comment">--   _ &#8594; None</span><span>
</span><span id="line-112"></span><span class="hs-comment">-- </span><span>
</span><span id="line-113"></span><span class="hs-comment">-- -- vectors --</span><span>
</span><span id="line-114"></span><span class="hs-comment">-- </span><span>
</span><span id="line-115"></span><span class="hs-comment">-- data B&#7437; (m &#8759; T&#8469;) (n &#8759; T&#8469;) a where</span><span>
</span><span id="line-116"></span><span class="hs-comment">--   B&#7437; &#8759; (R&#8469; m,R&#8469; n) </span><span>
</span><span id="line-117"></span><span class="hs-comment">--      &#8658; { rowsB&#7437; &#8759; S&#8469;32 m</span><span>
</span><span id="line-118"></span><span class="hs-comment">--        , colsB&#7437; &#8759; S&#8469;32 n</span><span>
</span><span id="line-119"></span><span class="hs-comment">--        , dataB&#7437; &#8759; Repa.Array Repa.V (Repa.Z Repa.:. HS.Int Repa.:. HS.Int) a</span><span>
</span><span id="line-120"></span><span class="hs-comment">--        }</span><span>
</span><span id="line-121"></span><span class="hs-comment">--      &#8594; B&#7437; m n a</span><span>
</span><span id="line-122"></span><span class="hs-comment">-- data U&#7437; (m &#8759; T&#8469;) (n &#8759; T&#8469;) a where</span><span>
</span><span id="line-123"></span><span class="hs-comment">--   U&#7437; &#8759; (R&#8469; m,R&#8469; n,Repa.Unbox a)</span><span>
</span><span id="line-124"></span><span class="hs-comment">--      &#8658; { rowsU&#7437; &#8759; S&#8469;32 m</span><span>
</span><span id="line-125"></span><span class="hs-comment">--        , colsU&#7437; &#8759; S&#8469;32 n</span><span>
</span><span id="line-126"></span><span class="hs-comment">--        , dataU&#7437; &#8759; Repa.Array Repa.U (Repa.Z Repa.:. HS.Int Repa.:. HS.Int) a</span><span>
</span><span id="line-127"></span><span class="hs-comment">--        }</span><span>
</span><span id="line-128"></span><span class="hs-comment">--      &#8594; U&#7437; m n a</span><span>
</span><span id="line-129"></span><span class="hs-comment">-- data V&#7437; (m &#8759; T&#8469;) (n &#8759; T&#8469;) a where</span><span>
</span><span id="line-130"></span><span class="hs-comment">--   V&#7437; &#8759; (R&#8469; m,R&#8469; n)</span><span>
</span><span id="line-131"></span><span class="hs-comment">--      &#8658; { rowsV&#7437; &#8759; S&#8469;32 m</span><span>
</span><span id="line-132"></span><span class="hs-comment">--        , colsV&#7437; &#8759; S&#8469;32 n</span><span>
</span><span id="line-133"></span><span class="hs-comment">--        , dataV&#7437; &#8759; Repa.Array Repa.D (Repa.Z Repa.:. HS.Int Repa.:. HS.Int) a</span><span>
</span><span id="line-134"></span><span class="hs-comment">--        }</span><span>
</span><span id="line-135"></span><span class="hs-comment">--      &#8594; V&#7437; m n a</span><span>
</span><span id="line-136"></span><span class="hs-comment">-- </span><span>
</span><span id="line-137"></span><span class="hs-comment">-- infixl 7 &#119082;</span><span>
</span><span id="line-138"></span><span class="hs-comment">-- class Matrix t where </span><span>
</span><span id="line-139"></span><span class="hs-comment">--   xrows &#8759; t m n a &#8594; S&#8469;32 m</span><span>
</span><span id="line-140"></span><span class="hs-comment">--   xcols &#8759; t m n a &#8594; S&#8469;32 n</span><span>
</span><span id="line-141"></span><span class="hs-comment">--   (&#119082;) &#8759; t m n a &#8594; (&#120128;32 m,&#120128;32 n) &#8594; a</span><span>
</span><span id="line-142"></span><span class="hs-comment">--   xvirt &#8759; t m n a &#8594; V&#7437; m n a</span><span>
</span><span id="line-143"></span><span class="hs-comment">-- </span><span>
</span><span id="line-144"></span><span class="hs-comment">-- -- boxed --</span><span>
</span><span id="line-145"></span><span class="hs-comment">-- </span><span>
</span><span id="line-146"></span><span class="hs-comment">-- indexB&#7437; &#8759; &#120128;32 m &#8594; &#120128;32 n &#8594; B&#7437; m n a &#8594; a</span><span>
</span><span id="line-147"></span><span class="hs-comment">-- indexB&#7437; i j xs = Repa.unsafeIndex (dataB&#7437; xs) (Repa.Z Repa.:. HS.fromIntegral (un&#120128;32 i) Repa.:. HS.fromIntegral (un&#120128;32 j))</span><span>
</span><span id="line-148"></span><span class="hs-comment">-- </span><span>
</span><span id="line-149"></span><span class="hs-comment">-- virtB&#7437; &#8759; B&#7437; m n a &#8594; V&#7437; m n a</span><span>
</span><span id="line-150"></span><span class="hs-comment">-- virtB&#7437; (B&#7437; m n xs) = V&#7437; m n $ Repa.delay xs</span><span>
</span><span id="line-151"></span><span class="hs-comment">-- </span><span>
</span><span id="line-152"></span><span class="hs-comment">-- instance Matrix B&#7437; where </span><span>
</span><span id="line-153"></span><span class="hs-comment">--   xrows = rowsB&#7437;</span><span>
</span><span id="line-154"></span><span class="hs-comment">--   xcols = colsB&#7437;</span><span>
</span><span id="line-155"></span><span class="hs-comment">--   xs &#119082; (i,j) = indexB&#7437; i j xs</span><span>
</span><span id="line-156"></span><span class="hs-comment">--   xvirt = virtB&#7437;</span><span>
</span><span id="line-157"></span><span class="hs-comment">-- </span><span>
</span><span id="line-158"></span><span class="hs-comment">-- -- unboxed --</span><span>
</span><span id="line-159"></span><span class="hs-comment">-- </span><span>
</span><span id="line-160"></span><span class="hs-comment">-- indexU&#7437; &#8759; &#120128;32 m &#8594; &#120128;32 n &#8594; U&#7437; m n a &#8594; a</span><span>
</span><span id="line-161"></span><span class="hs-comment">-- indexU&#7437; i j (U&#7437; _ _ xs) = Repa.unsafeIndex xs (Repa.Z Repa.:. HS.fromIntegral (un&#120128;32 i) Repa.:. HS.fromIntegral (un&#120128;32 j))</span><span>
</span><span id="line-162"></span><span class="hs-comment">-- </span><span>
</span><span id="line-163"></span><span class="hs-comment">-- virtU&#7437; &#8759; U&#7437; m n a &#8594; V&#7437; m n a</span><span>
</span><span id="line-164"></span><span class="hs-comment">-- virtU&#7437; (U&#7437; m n xs) = V&#7437; m n $ Repa.delay xs</span><span>
</span><span id="line-165"></span><span class="hs-comment">-- </span><span>
</span><span id="line-166"></span><span class="hs-comment">-- instance Matrix U&#7437; where </span><span>
</span><span id="line-167"></span><span class="hs-comment">--   xrows = rowsU&#7437;</span><span>
</span><span id="line-168"></span><span class="hs-comment">--   xcols = colsU&#7437;</span><span>
</span><span id="line-169"></span><span class="hs-comment">--   xs &#119082; (i,j) = indexU&#7437; i j xs</span><span>
</span><span id="line-170"></span><span class="hs-comment">--   xvirt = virtU&#7437;</span><span>
</span><span id="line-171"></span><span class="hs-comment">-- </span><span>
</span><span id="line-172"></span><span class="hs-comment">-- -- virtual --</span><span>
</span><span id="line-173"></span><span class="hs-comment">-- </span><span>
</span><span id="line-174"></span><span class="hs-comment">-- indexV&#7437; &#8759; &#120128;32 m &#8594; &#120128;32 n &#8594; V&#7437; m n a &#8594; a</span><span>
</span><span id="line-175"></span><span class="hs-comment">-- indexV&#7437; i j xs = Repa.unsafeIndex (dataV&#7437; xs) (Repa.Z Repa.:. HS.fromIntegral (un&#120128;32 i) Repa.:. HS.fromIntegral (un&#120128;32 j)) </span><span>
</span><span id="line-176"></span><span class="hs-comment">-- </span><span>
</span><span id="line-177"></span><span class="hs-comment">-- instance Matrix V&#7437; where</span><span>
</span><span id="line-178"></span><span class="hs-comment">--   xrows = rowsV&#7437;</span><span>
</span><span id="line-179"></span><span class="hs-comment">--   xcols = colsV&#7437;</span><span>
</span><span id="line-180"></span><span class="hs-comment">--   xs &#119082; (i,j) = indexV&#7437; i j xs</span><span>
</span><span id="line-181"></span><span class="hs-comment">--   xvirt = id</span><span>
</span><span id="line-182"></span><span class="hs-comment">-- </span><span>
</span><span id="line-183"></span><span class="hs-comment">-- matrix &#8759; (R&#8469; m,R&#8469; n) &#8658; S&#8469;32 m &#8594; S&#8469;32 n &#8594; (&#120128;32 m &#8594; &#120128;32 n &#8594; a) &#8594; V&#7437; m n a</span><span>
</span><span id="line-184"></span><span class="hs-comment">-- matrix m n f = </span><span>
</span><span id="line-185"></span><span class="hs-comment">--   V&#7437; m n $ Repa.fromFunction (Repa.Z Repa.:. HS.fromIntegral (unS&#8469;32 m) Repa.:. HS.fromIntegral (unS&#8469;32 n)) $ \ (Repa.Z Repa.:. i Repa.:. j) &#8594; </span><span>
</span><span id="line-186"></span><span class="hs-comment">--     d&#120159;32 (HS.fromIntegral i) $ \ i' &#8594; </span><span>
</span><span id="line-187"></span><span class="hs-comment">--       d&#120159;32 (HS.fromIntegral j) $ \ j' &#8594;</span><span>
</span><span id="line-188"></span><span class="hs-comment">--         f (&#120128;32 i' TRUSTME_LT) (&#120128;32 j' TRUSTME_LT)</span><span>
</span><span id="line-189"></span><span class="hs-comment">-- </span><span>
</span><span id="line-190"></span><span class="hs-comment">-- xconst &#8759; (R&#8469; m,R&#8469; n) &#8658; S&#8469;32 m &#8594; S&#8469;32 n &#8594; a &#8594; V&#7437; m n a</span><span>
</span><span id="line-191"></span><span class="hs-comment">-- xconst m n x = matrix m n $ \ _ _ &#8594; x</span><span>
</span><span id="line-192"></span><span class="hs-comment">-- </span><span>
</span><span id="line-193"></span><span class="hs-comment">-- xbs &#8759; V&#7437; m n a &#8594; B&#7437; m n a</span><span>
</span><span id="line-194"></span><span class="hs-comment">-- xbs (V&#7437; m n xs) = B&#7437; m n $ Repa.computeS xs</span><span>
</span><span id="line-195"></span><span class="hs-comment">-- </span><span>
</span><span id="line-196"></span><span class="hs-comment">-- xbp &#8759; V&#7437; m n a &#8594; B&#7437; m n a</span><span>
</span><span id="line-197"></span><span class="hs-comment">-- xbp (V&#7437; m n xs) = B&#7437; m n $ HS.runIdentity $ Repa.computeP xs</span><span>
</span><span id="line-198"></span><span class="hs-comment">-- </span><span>
</span><span id="line-199"></span><span class="hs-comment">-- xus &#8759; (Repa.Unbox a) &#8658; V&#7437; m n a &#8594; U&#7437; m n a</span><span>
</span><span id="line-200"></span><span class="hs-comment">-- xus (V&#7437; m n xs) = U&#7437; m n $ Repa.computeS xs</span><span>
</span><span id="line-201"></span><span class="hs-comment">-- </span><span>
</span><span id="line-202"></span><span class="hs-comment">-- xup &#8759; (Repa.Unbox a) &#8658; V&#7437; m n a &#8594; U&#7437; m n a</span><span>
</span><span id="line-203"></span><span class="hs-comment">-- xup (V&#7437; m n xs) = U&#7437; m n $ HS.runIdentity $ Repa.computeP xs</span><span>
</span><span id="line-204"></span><span class="hs-comment">-- </span><span>
</span><span id="line-205"></span><span class="hs-comment">-- xiter &#8759; V&#7437; m n a &#8594; &#119868; a</span><span>
</span><span id="line-206"></span><span class="hs-comment">-- xiter xs = iter $ Repa.toList $ dataV&#7437; xs</span><span>
</span><span id="line-207"></span><span class="hs-comment">-- </span><span>
</span><span id="line-208"></span><span class="hs-comment">-- instance ToIter a (B&#7437; m n a) where iter = iter &#8728; xvirt</span><span>
</span><span id="line-209"></span><span class="hs-comment">-- instance ToIter a (U&#7437; m n a) where iter = iter &#8728; xvirt</span><span>
</span><span id="line-210"></span><span class="hs-comment">-- instance ToIter a (V&#7437; m n a) where iter = xiter</span><span>
</span><span id="line-211"></span><span class="hs-comment">-- </span><span>
</span><span id="line-212"></span><span class="hs-comment">-- -------------</span><span>
</span><span id="line-213"></span><span class="hs-comment">-- -- DERIVED --</span><span>
</span><span id="line-214"></span><span class="hs-comment">-- -------------</span><span>
</span><span id="line-215"></span><span class="hs-comment">-- </span><span>
</span><span id="line-216"></span><span class="hs-comment">-- xtranspose &#8759; V&#7437; m n a &#8594; V&#7437; n m a</span><span>
</span><span id="line-217"></span><span class="hs-comment">-- xtranspose xs@(V&#7437; _ _ _) = matrix (xcols xs) (xrows xs) $ \ j i &#8594; xs &#119082; (i,j)</span><span>
</span><span id="line-218"></span><span class="hs-comment">-- </span><span>
</span><span id="line-219"></span><span class="hs-comment">-- xmap &#8759; (a &#8594; b) &#8594; V&#7437; m n a &#8594; V&#7437; m n b</span><span>
</span><span id="line-220"></span><span class="hs-comment">-- xmap f xs@(V&#7437; _ _ _) = matrix (xrows xs) (xcols xs) $ \ i j &#8594; f $ xs &#119082; (i,j)</span><span>
</span><span id="line-221"></span><span class="hs-comment">-- </span><span>
</span><span id="line-222"></span><span class="hs-comment">-- instance Functor (V&#7437; m n) where map = xmap</span><span>
</span><span id="line-223"></span><span class="hs-comment">-- </span><span>
</span><span id="line-224"></span><span class="hs-comment">-- xmap2 &#8759; (a &#8594; b &#8594; c) &#8594; V&#7437; m n a &#8594; V&#7437; m n b &#8594; V&#7437; m n c</span><span>
</span><span id="line-225"></span><span class="hs-comment">-- xmap2 f xs@(V&#7437; _ _ _) ys@(V&#7437; _ _ _) = matrix (xrows xs) (xcols xs) $ \ i j &#8594; f (xs &#119082; (i,j)) (ys &#119082; (i,j))</span><span>
</span><span id="line-226"></span><span class="hs-comment">-- </span><span>
</span><span id="line-227"></span><span class="hs-comment">-- xmeld &#8759; (R&#8469; n) &#8658; S&#8469;32 n &#8594; V&#7437; m 1 (V&#7437; 1 n a) &#8594; V&#7437; m n a</span><span>
</span><span id="line-228"></span><span class="hs-comment">-- xmeld n xys@(V&#7437; _ _ _) = matrix (xrows xys) n $ \ i j &#8594; indexV&#7437; (s&#120154; @ 0 P) j $ indexV&#7437; i (s&#120154; @ 0 P) xys</span><span>
</span><span id="line-229"></span><span class="hs-comment">-- </span><span>
</span><span id="line-230"></span><span class="hs-comment">-- xsplit &#8759; V&#7437; m n a &#8594; V&#7437; m 1 (V&#7437; 1 n a)</span><span>
</span><span id="line-231"></span><span class="hs-comment">-- xsplit xys@(V&#7437; _ _ _) = matrix (xrows xys) (s&#120159;32 @ 1) $ \ i _ &#8594; matrix (s&#120159;32 @ 1) (colsV&#7437; xys) $ \ _ j &#8594; indexV&#7437; i j xys</span><span>
</span><span id="line-232"></span><span class="hs-comment">-- </span><span>
</span><span id="line-233"></span><span class="hs-comment">-- xrow &#8759; &#120128;32 m &#8594; V&#7437; m n a &#8594; V&#7437; 1 n a</span><span>
</span><span id="line-234"></span><span class="hs-comment">-- xrow i xs@(V&#7437; _ _ _) = matrix (s&#120159;32 @ 1) (colsV&#7437; xs) $ \ _ j &#8594; indexV&#7437; i j xs</span><span>
</span><span id="line-235"></span><span class="hs-comment">-- </span><span>
</span><span id="line-236"></span><span class="hs-comment">-- xcol &#8759; &#120128;32 n &#8594; V&#7437; m n a &#8594; V&#7437; 1 m a</span><span>
</span><span id="line-237"></span><span class="hs-comment">-- xcol i xs = xrow i $ xtranspose xs</span><span>
</span><span id="line-238"></span><span class="hs-comment">-- </span><span>
</span><span id="line-239"></span><span class="hs-comment">-- xproduct &#8759; (Additive a,Times a) &#8658; V&#7437; m n a &#8594; V&#7437; n o a &#8594; V&#7437; m o a</span><span>
</span><span id="line-240"></span><span class="hs-comment">-- xproduct xs@(V&#7437; _ _ _) ys@(V&#7437; _ _ _) =</span><span>
</span><span id="line-241"></span><span class="hs-comment">--   matrix (xrows xs) (xcols ys) $ \ i k &#8594;</span><span>
</span><span id="line-242"></span><span class="hs-comment">--     let r&#8321; = xrow i xs</span><span>
</span><span id="line-243"></span><span class="hs-comment">--         r&#8322; = xcol k ys</span><span>
</span><span id="line-244"></span><span class="hs-comment">--     in sum $ iter $ xmap2 (&#215;) r&#8321; r&#8322;</span><span>
</span><span id="line-245"></span><span class="hs-comment">-- </span><span>
</span><span id="line-246"></span><span class="hs-comment">-- xbmapM &#8759; (Monad m) &#8658; (a &#8594; m b) &#8594; V&#7437; n o a &#8594; m (B&#7437; n o b)</span><span>
</span><span id="line-247"></span><span class="hs-comment">-- xbmapM f xs@(V&#7437; _ _ _) = do</span><span>
</span><span id="line-248"></span><span class="hs-comment">--   xs' &#8592; mapM (mapM f) $ xlist2 xs</span><span>
</span><span id="line-249"></span><span class="hs-comment">--   return $ xb xs' $ \ (B&#7437; _ _ xs'') &#8594; B&#7437; (xrows xs) (xcols xs) xs''</span><span>
</span><span id="line-250"></span><span class="hs-comment">-- </span><span>
</span><span id="line-251"></span><span class="hs-comment">-- xumapM &#8759; (Monad m,Repa.Unbox a,Repa.Unbox b) &#8658; (a &#8594; m b) &#8594; V&#7437; n o a &#8594; m (U&#7437; n o b)</span><span>
</span><span id="line-252"></span><span class="hs-comment">-- xumapM f xs@(V&#7437; _ _ _) = do</span><span>
</span><span id="line-253"></span><span class="hs-comment">--   xs' &#8592; mapM (mapM f) $ xlist2 xs</span><span>
</span><span id="line-254"></span><span class="hs-comment">--   return $ xu xs' $ \ (U&#7437; _ _ xs'') &#8594; U&#7437; (xrows xs) (xcols xs) xs''</span><span>
</span><span id="line-255"></span><span class="hs-comment">-- </span><span>
</span><span id="line-256"></span><span class="hs-comment">-- xindirect &#8759; V&#7437; m n a &#8594; V&#7437; 1 o (&#120128;32 m) &#8594; V&#7437; o n a</span><span>
</span><span id="line-257"></span><span class="hs-comment">-- xindirect xs@(V&#7437; _ _ _) is@(V&#7437; _ _ _) = matrix (xcols is) (xcols xs) $ \ o n &#8594; xs &#119082; (is &#119082; (s&#120154; @ 0 P,o),n)</span><span>
</span><span id="line-258"></span><span class="hs-comment">-- </span><span>
</span><span id="line-259"></span><span class="hs-comment">-- xiter2 &#8759; V&#7437; m n a &#8594; &#119868; (&#119868; a)</span><span>
</span><span id="line-260"></span><span class="hs-comment">-- xiter2 = map iter &#8728; iter &#8728; xsplit</span><span>
</span><span id="line-261"></span><span class="hs-comment">-- </span><span>
</span><span id="line-262"></span><span class="hs-comment">-- xlist2 &#8759; V&#7437; m n a &#8594; &#119871; (&#119871; a)</span><span>
</span><span id="line-263"></span><span class="hs-comment">-- xlist2 = list &#8728; map list &#8728; xiter2</span><span>
</span><span id="line-264"></span><span class="hs-comment">-- </span><span>
</span><span id="line-265"></span><span class="hs-comment">-- xb&#119868; &#8759; &#119868; (&#119868; a) &#8594; (&#8704; m n. (R&#8469; m,R&#8469; n) &#8658; B&#7437; m n a &#8594; b) &#8594; b</span><span>
</span><span id="line-266"></span><span class="hs-comment">-- xb&#119868; xs f =</span><span>
</span><span id="line-267"></span><span class="hs-comment">--   let uc = joins $ map (nat&#937;32 &#8728; count) xs</span><span>
</span><span id="line-268"></span><span class="hs-comment">--       lc = meets $ map (AddTop &#8728; nat&#937;32 &#8728; count) xs</span><span>
</span><span id="line-269"></span><span class="hs-comment">--   in case AddTop uc &#8801; lc of</span><span>
</span><span id="line-270"></span><span class="hs-comment">--     True &#8594; </span><span>
</span><span id="line-271"></span><span class="hs-comment">--       d&#120159;32 uc $ \ n &#8594;</span><span>
</span><span id="line-272"></span><span class="hs-comment">--       d&#120159;32 (nat&#937;32 $ count xs) $ \ m &#8594;</span><span>
</span><span id="line-273"></span><span class="hs-comment">--         f $ B&#7437; m n $ Repa.fromList (Repa.Z Repa.:. HS.fromIntegral (unS&#8469;32 m) Repa.:. HS.fromIntegral (unS&#8469;32 n)) $ lazyList $ concat xs</span><span>
</span><span id="line-274"></span><span class="hs-comment">--     False &#8594; error &quot;`xb&#119871;`: bad input list: input list is either empty (no columns) or has columns of different length&quot;</span><span>
</span><span id="line-275"></span><span class="hs-comment">-- </span><span>
</span><span id="line-276"></span><span class="hs-comment">-- xb &#8759; (ToIter a t,ToIter t u) &#8658; u &#8594; (&#8704; m n. (R&#8469; m,R&#8469; n) &#8658; B&#7437; m n a &#8594; b) &#8594; b</span><span>
</span><span id="line-277"></span><span class="hs-comment">-- xb xs f = xb&#119868; (map iter (iter xs)) f</span><span>
</span><span id="line-278"></span><span class="hs-comment">-- </span><span>
</span><span id="line-279"></span><span class="hs-comment">-- xu&#119868; &#8759; (Repa.Unbox a) &#8658; &#119868; (&#119868; a) &#8594; (&#8704; m n. (R&#8469; m,R&#8469; n) &#8658; U&#7437; m n a &#8594; b) &#8594; b</span><span>
</span><span id="line-280"></span><span class="hs-comment">-- xu&#119868; xs f =</span><span>
</span><span id="line-281"></span><span class="hs-comment">--   let uc = joins $ map (nat&#937;32 &#8728; count) xs</span><span>
</span><span id="line-282"></span><span class="hs-comment">--       lc = meets $ map (AddTop &#8728; nat&#937;32 &#8728; count) xs</span><span>
</span><span id="line-283"></span><span class="hs-comment">--   in case AddTop uc &#8801; lc of</span><span>
</span><span id="line-284"></span><span class="hs-comment">--     True &#8594; </span><span>
</span><span id="line-285"></span><span class="hs-comment">--       d&#120159;32 uc $ \ n &#8594;</span><span>
</span><span id="line-286"></span><span class="hs-comment">--       d&#120159;32 (nat&#937;32 $ count xs) $ \ m &#8594;</span><span>
</span><span id="line-287"></span><span class="hs-comment">--         f $ U&#7437; m n $ Repa.fromList (Repa.Z Repa.:. HS.fromIntegral (unS&#8469;32 m) Repa.:. HS.fromIntegral (unS&#8469;32 n)) $ lazyList $ concat xs</span><span>
</span><span id="line-288"></span><span class="hs-comment">--     False &#8594; error &quot;`xb&#119871;`: bad input list: input list is either empty (no columns) or has columns of different length&quot;</span><span>
</span><span id="line-289"></span><span class="hs-comment">-- </span><span>
</span><span id="line-290"></span><span class="hs-comment">-- xu &#8759; (Repa.Unbox a,ToIter a t,ToIter t u) &#8658; u &#8594; (&#8704; m n. (R&#8469; m,R&#8469; n) &#8658; U&#7437; m n a &#8594; b) &#8594; b</span><span>
</span><span id="line-291"></span><span class="hs-comment">-- xu xs f = xu&#119868; (map iter (iter xs)) f</span><span>
</span><span id="line-292"></span><span class="hs-comment">-- </span><span>
</span><span id="line-293"></span><span class="hs-comment">-- instance (Times a) &#8658; Times (V&#7437; m n a) where (&#215;) = xmap2 (&#215;)</span><span>
</span><span id="line-294"></span><span class="hs-comment">-- </span><span>
</span><span id="line-295"></span><span class="hs-comment">-- (&#10006;) &#8759; (Additive a,Times a) &#8658; V&#7437; m n a &#8594; V&#7437; n o a &#8594; V&#7437; m o a</span><span>
</span><span id="line-296"></span><span class="hs-comment">-- (&#10006;) = xproduct</span><span>
</span><span id="line-297"></span><span class="hs-comment">-- </span><span>
</span><span id="line-298"></span><span class="hs-comment">-- testMatrix1 &#8759; IO ()</span><span>
</span><span id="line-299"></span><span class="hs-comment">-- testMatrix1 = do</span><span>
</span><span id="line-300"></span><span class="hs-comment">--   let xs = list [list [1,2,3],list [4,5,6],list [7,8,9]]</span><span>
</span><span id="line-301"></span><span class="hs-comment">--   shout xs</span><span>
</span><span id="line-302"></span><span class="hs-comment">--   xb xs $ \ xs' &#8594; do</span><span>
</span><span id="line-303"></span><span class="hs-comment">--     let ys = xlist2 $ xtranspose $ xvirt xs'</span><span>
</span><span id="line-304"></span><span class="hs-comment">--     shout ys</span><span>
</span><span id="line-305"></span><span class="hs-comment">-- </span><span>
</span><span id="line-306"></span></pre></body></html>